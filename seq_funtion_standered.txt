Input arguments:

fov: tuple of floats
Nread: int
Nphase: int
Npart: int
FA / FA_ref / FA_ex: tensor
shim / shim_ref / shim_ex: tensor
TR: tensor
TR_shot: tensor
TE: tensor
esp: tensor
etl: int
slice_thickness: float
encoding: string
R: tuple of 2, (Ry, Rz)
R_delta: int, (Caipi-shift)
pf_factor: tuple of ints (x,y,z)
oversampling: int
bw: int
n_shot: int
n_dummyshot: int
n_dummypulse: int
delay_start: int,
delay_end: int
experiment_id: string
system: optional, None or system
verbose: bool, default False


Standard parameter:

fov=(220e-3,220e-3,8e-3)
Nread = 96
Nphase = 96
Npart = 1


Definitions

seq.setDefinition('name', sequence name); # name
seq.setDefinition('fov', [fov_x fov_y sliceThickness]); # fov in m
seq.setDefinition('matrix', [Nread Nphase Npart]);      # nominal matrix size

General structure

Just use torch
Sequence should be a functions
Sequence name: seq_sequenceName (e.g. seq_FLASH(arg))
Return seq object